package fruit.health.server.util;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.URLEncoder;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

import com.google.appengine.api.utils.SystemProperty;

import fruit.health.server.auditlog.AuditEvent;
import fruit.health.server.auditlog.AuditLogger;
import fruit.health.shared.dto.LoginInfo;
import fruit.health.shared.util.InlineMap;
import fruit.health.shared.util.SharedConstants;

public class Utils
{
    private static final Logger logger = LoggerFactory.getLogger(Utils.class);
    private static final AuditLogger auditLogger = new AuditLogger();

    public static final String SESSION_LOGIN_INFO_ATTRIBUTE = "login.info";

    public static String urlEncode (String in)
    {
        try
        {
            return URLEncoder.encode(in, Constants.UTF8.name());
        }
        catch (UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
    }

    public static String bytesToHexString (byte[] bytes)
    {
        if (null == bytes)
        {
            return null;
        }
        return new String(Hex.encodeHex(bytes));
    }

    public static String bytesToBase64UrlSafe(byte[] bytes)
    {
        return Base64.encodeBase64URLSafeString(bytes);
    }

    public static String bytesToBase64(byte[] bytes)
    {
        return Base64.encodeBase64String(bytes);
    }

    public static byte[] base64Decode(String encoded)
    {
        return Base64.decodeBase64(encoded);
    }
    
    /**
     * @param numBytes The number of random bytes to generate
     * @return A hex encoded string of the given number of randomly generated bytes
     */
    public static String randomHexString(int numBytes)
    {
        return bytesToHexString(RandomNumberGenerator.getBytes(numBytes));
    }
    
    /*
     * From: http://www.kodejava.org/examples/266.html
     */
    public String convertStreamToString (InputStream is) throws IOException
    {
        /*
         * To convert the InputStream to String we use the Reader.read(char[]
         * buffer) method. We iterate until the Reader return -1 which means
         * there's no more data to read. We use the StringWriter class to
         * produce the string.
         */
        if (is != null)
        {
            Writer writer = new StringWriter();

            char[] buffer = new char[1024];
            try
            {
                Reader reader = new BufferedReader(new InputStreamReader(is,
                        Constants.UTF8));
                int n;
                while ((n = reader.read(buffer)) != -1)
                {
                    writer.write(buffer, 0, n);
                }
            }
            finally
            {
                is.close();
            }
            return writer.toString();
        }
        else
        {
            return "";
        }
    }

    /**
     * Given a field name, return its getter method. For this to work, the class
     * must follow standard getter / setter naming conventions.
     * <p/>
     * This is done by first getting the expected name of the getter method.
     * Which is in turn obtained by capitalizing the first letter of the name
     * and prepending it with "is" if the field is of type boolean, otherwise we
     * prepend it with "get". Then, we use this to get the method.
     *
     * @param field
     *            The name of the field
     * @return The getter method for the field.
     * @throws NoSuchMethodException
     * @throws SecurityException
     */
    public static Method convertToGetterMethod (Field field)
            throws SecurityException, NoSuchMethodException
    {
        String name = field.getName();
        String prefix;
        Class<?> type = field.getType();
        if (type.equals(boolean.class))
        {
            prefix = "is";
        }
        else
        {
            prefix = "get";
        }
        return field.getDeclaringClass().getMethod(prefix
                + Character.toUpperCase(name.charAt(0)) + name.substring(1));
    }

    /**
     * Given a field name, return its setter method. For this to work, the class
     * must follow standard getter / setter naming conventions.
     * <p/>
     * This is done by first getting the expected name of the setter method.
     * Which is in turn obtained by capitalizing the first letter of the name
     * and prepending it with "set". Then, we use this to get the method.
     *
     * @param field
     *            The name of the field
     * @return The setter method for the field.
     * @throws NoSuchMethodException
     * @throws SecurityException
     */
    public static Method convertToSetterMethod (Field field)
            throws SecurityException, NoSuchMethodException
    {
        String name = field.getName();
        return field.getDeclaringClass().getMethod("set"
                + Character.toUpperCase(name.charAt(0)) + name.substring(1),
                field.getType());
    }

    public static String generateTimestampedId ()
    {
        String visitId = Long.toString(new Date().getTime() / 1000 / 60 - 21564000) // XXX make named constant
                + "-"
                + Utils.randomHexString(Constants.BROWSER_ID_BYTES);

        MDC.put("visitId", visitId);

        return visitId;
    }

    // Hack Till GAE/J bug 6465 is fixed
    private static String serverInstanceId = Long.toHexString(new Random().nextLong());
    private static String commitId = ServerProperties.getCommitId();
    private static final AtomicInteger requestNumber = new AtomicInteger(0);

    public static void setupMdc (HttpServletRequest request, HttpServletResponse response)
    {
        MDC.put("ver", commitId);
        MDC.put("reqNum",
                serverInstanceId + "-" + requestNumber.incrementAndGet());

        String visitId = request.getHeader(SharedConstants.VISIT_ID_HEADER);
        if (null != visitId)
        {
            MDC.put("visitId", visitId);
        }

        Cookie browserCookie = CookieUtils.getCookie(request,
                SharedConstants.BROWSER_COOKIE_NAME);
        if (null != browserCookie)
        {
            MDC.put("browser", browserCookie.getValue());
        }
        else
        {
            createBrowserCookie(request, response);
        }

        LoginInfo creds = getCredsFromSession(request.getSession(false));
        if (null != creds)
        {
            MDC.put("userId", Long.toString(creds.getUser().getUserId()));
            MDC.put("session", creds.getSessionTracker());
            if (null != creds.getAdmin())
            {
                MDC.put("admin", creds.getAdmin());
            }
        }
    }

    private static void createBrowserCookie (final HttpServletRequest request, HttpServletResponse response)
    {
        final String browserCookieVal = Constants.BROWSER_COOKIE_VERSION + Utils.randomHexString(Constants.BROWSER_ID_BYTES);

        auditLogger.log(AuditEvent.BROWSER_ID_GENERATED, new InlineMap() {{
            _("browserId", browserCookieVal);
            _("userAgent", request.getHeader("User-Agent"));
            _("sourceIP", request.getRemoteAddr());
            _("referrer", request.getHeader("Referer"));
        }});

        CookieUtils.setCookie(response, SharedConstants.BROWSER_COOKIE_NAME, browserCookieVal, Constants.BCOOKIE_AGE);

        // Add the newly generate cookie to MDC
        MDC.put("browser", browserCookieVal);
    }

    private static ThreadLocal<LoginInfo> credsHolder = new ThreadLocal<LoginInfo>();

    public static LoginInfo getCredsFromSession (HttpSession session)
    {
        LoginInfo creds = credsHolder.get();
        if (null != creds)
        {
            logger.trace("getCredsFromSession: returning creds from local thread");
            return creds;
        }

        if (null == session)
        {
            logger.trace("getCredsFromSession: no session");
            return null;
        }

        creds = (LoginInfo)session.getAttribute(Constants.SESSION_LOGIN_INFO_ATTRIBUTE);
        if (null != creds)
        {
            // The processing of this request could modify the creds object. So
            // we will need to put it back into the
            // session. So, we store a pointer to it and re-store the (possibly)
            // dirty object back in
            // the session on the way out.
            // Why do we need to store it in the thread? (As opposed to just
            // getting it _again_ from the session)
            // Because HttpSession.getAttribute(String) does not guarantee that
            // it returns the same object instance
            // for 2 calls with the same arguments. (It could, for instance,
            // deserialize the stored object in the session
            // each time you make a call).
            credsHolder.set(creds);
            logger.trace("getCredsFromSession: setting creds for local thread");
        }
        return creds;
    }

    public static void restoreCredsIfDirtyAndClear (HttpServletRequest request)
    {
        LoginInfo creds = credsHolder.get();
        if (null != creds)
        {
            // If we get here, then we expect to have a session, at the very
            // least
            request.getSession(false)
                    .setAttribute(Constants.SESSION_LOGIN_INFO_ATTRIBUTE, creds);
            logger.trace("restoreCredsIfDirtyAndClear: Reset creds in session");
        }
        credsHolder.remove();
        logger.trace("restoreCredsIfDirtyAndClear: removed creds from local thread");
    }

    public static void clearCreds ()
    {
        logger.trace("clearCreds: clearing local thread creds");
        credsHolder.remove();
    }

    /**
     * For debugging only. Dumps out the headers / state of the request. Returns
     * it as a string.
     */
    public static String dumpRequestMetadata (HttpServletRequest request)
    {
        String path = request.getRequestURI();
        String query = request.getQueryString();

        String url = null == query ? path : path + "?" + query;

        Map<String, Object> headers = new LinkedHashMap<String, Object>();
        for (Enumeration<?> e = request.getHeaderNames(); e.hasMoreElements();)
        {
            String headerName = (String)e.nextElement();

            List<String> values = new LinkedList<String>();
            for (Enumeration<?> en = request.getHeaders(headerName); en.hasMoreElements();)
            {
                String value = (String)en.nextElement();

                values.add(value);
            }

            if (1 == values.size())
            {
                headers.put(headerName, values.get(0));
            }
            else
            {
                headers.put(headerName, values);
            }
        }

        Map<String, Object> attributes = new HashMap<String, Object>();
        for (Enumeration<?> e = request.getAttributeNames(); e.hasMoreElements();)
        {
            String attributeName = (String)e.nextElement();

            attributes.put(attributeName, request.getAttribute(attributeName));
        }

        Map<String, Object> sessionAttributes = new HashMap<String, Object>();
        if (null != request.getSession(false))
        {
            for (Enumeration<?> e = request.getSession(false)
                    .getAttributeNames(); e.hasMoreElements();)
            {
                String attrib = (String)e.nextElement();
                sessionAttributes.put(attrib, request.getSession(false)
                        .getAttribute(attrib));
            }
        }

        return String.format("%s:%d servicing request %s from %s:%d; url = '%s'; headers = %s;"
                + " attributes = %s; session = %s",
                request.getLocalAddr(),
                request.getLocalPort(),
                request.getMethod(),
                request.getRemoteAddr(),
                request.getRemotePort(),
                url,
                headers,
                attributes,
                sessionAttributes);
    }

    /**
     * @return true if we are in development mode
     */
    public static boolean inDevelopmentMode()
    {
        return SystemProperty.environment.value() == SystemProperty.Environment.Value.Development;
    }
}
